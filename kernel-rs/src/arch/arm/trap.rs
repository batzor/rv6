// TODO: this file needs refactoring

use core::mem;

use cortex_a::registers::*;
use tock_registers::interfaces::{Readable, Writeable};

use crate::{
    addr::PGSIZE,
    arch::{
        asm::{cpu_id, intr_get, intr_off, r_fpsr, w_fpsr},
        intr::INTERRUPT_CONTROLLER,
        memlayout::{MemLayout, TIMER0_IRQ},
        timer::Timer,
    },
    hal::hal,
    kernel::{kernel_ref, KernelRef},
    memlayout::IrqNumbers,
    memlayout::{TRAMPOLINE, TRAPFRAME},
    ok_or,
    proc::{kernel_ctx, KernelCtx, Procstate},
};

/// In ARM.v8 architecture, interrupts are part
/// of a more general term: exceptions.
enum ExceptionTypes {
    SyncException,
    IRQ,
    FIQ,
    SError,
}

impl ExceptionTypes {
    pub fn from_usize(n: usize) -> Self {
        match n {
            0 => Self::SyncException,
            1 => Self::IRQ,
            2 => Self::FIQ,
            3 => Self::SError,
            _ => panic!("invalud exception code"),
        }
    }
}

extern "C" {
    // trampoline.S
    static mut trampoline: [u8; 0];

    static mut userret: [u8; 0];
    fn vectors();
}

pub fn trapinit() {}

/// Set up to take exceptions and traps while in the kernel.
pub unsafe fn trapinitcore() {
    VBAR_EL1.set(vectors as _);
}

/// Handle an interrupt, exception, or system call from user space.
/// Called from trampoline.S.
#[no_mangle]
pub unsafe extern "C" fn usertrap(etype: usize) {
    let etype = ExceptionTypes::from_usize(etype);

    // SAFETY
    // * usertrap can be reached only after the initialization of the kernel.
    // * It's the beginning of this thread, so there's no exsiting `KernelCtx` or `CurrentProc`.
    unsafe { kernel_ctx(|ctx| ctx.user_trap(etype)) };
}

#[no_mangle]
pub unsafe extern "C" fn cur_el_sp0_handler(etype: usize) {
    // SAFETY
    let etype = ExceptionTypes::from_usize(etype);
    unsafe { kernel_ref(|kref| kref.kernel_trap_el1t(etype)) };
}

#[no_mangle]
pub unsafe extern "C" fn cur_el_sp1_handler(etype: usize) {
    // SAFETY
    let etype = ExceptionTypes::from_usize(etype);
    unsafe { kernel_ref(|kref| kref.kernel_trap_el1h(etype)) };
}

impl KernelCtx<'_, '_> {
    /// `user_trap` can be reached only from the user mode, so it is a method of `KernelCtx`.
    unsafe fn user_trap(mut self, etype: ExceptionTypes) -> ! {
        assert!(
            SPSR_EL1.matches_all(SPSR_EL1::M::EL0t),
            "usertrap: not from user mode(EL0)"
        );

        VBAR_EL1.set(vectors as _);

        self.proc_mut().trap_frame_mut().pc = ELR_EL1.get() as _;
        self.proc_mut().trap_frame_mut().spsr = SPSR_EL1.get() as _;

        let irq = match etype {
            ExceptionTypes::SyncException => {
                if ESR_EL1.matches_all(ESR_EL1::EC::SVC64) {
                    // system call

                    if self.proc().killed() {
                        self.kernel().procs().exit_current(-1, &mut self);
                    }

                    unsafe { crate::arch::asm::intr_on() };

                    let syscall_no = self.proc_mut().trap_frame_mut().r7 as i32;
                    self.proc_mut().trap_frame_mut().r0 =
                        ok_or!(self.syscall(syscall_no), usize::MAX);
                } else if ESR_EL1
                    .matches_any(ESR_EL1::EC::DataAbortLowerEL + ESR_EL1::EC::InstrAbortLowerEL)
                {
                    // MMU faults generated by data accesses or instruction access
                    // When the process accesses virtual address
                    // that has not been mapped yet.
                    self.kernel().print_state();
                    self.proc().kill();
                } else {
                    self.handle_bad_error();
                }
                0
            }
            ExceptionTypes::IRQ => unsafe { self.kernel().handle_irq() },
            ExceptionTypes::FIQ | ExceptionTypes::SError => {
                // TODO: add error message
                self.handle_bad_error();
            }
        };

        if self.proc().killed() {
            self.kernel().procs().exit_current(-1, &mut self);
        }

        // barrier();
        // Give up the CPU if this is a timer interrupt.
        if irq == 2 {
            self.yield_cpu();
        }

        unsafe { self.user_trap_ret() }
    }

    fn handle_bad_error(mut self) -> ! {
        self.proc().kill();
        self.kernel().procs().exit_current(-1, &mut self);
    }

    /// Return to user space.
    pub unsafe fn user_trap_ret(mut self) -> ! {
        // We're about to switch the destination of traps from
        // kerneltrap() to usertrap(), so turn off interrupts until
        // we're back in user space, where usertrap() is correct.
        intr_off();

        // Send syscalls, interrupts, and exceptions to trampoline.S.
        VBAR_EL1.set(TRAMPOLINE as u64);

        // kernel page table
        self.proc_mut().trap_frame_mut().kernel_satp = TTBR0_EL1.get() as usize;

        self.proc_mut().trap_frame_mut().kernel_trap = usertrap as usize;

        self.proc_mut().trap_frame_mut().kernel_sp =
            self.proc_mut().deref_mut_data().kstack + PGSIZE;

        // Tell trampoline.S the user page table to switch to.
        let user_table = self.proc().memory().page_table_addr();

        // Jump to trampoline.S at the top of memory, which
        // switches to the user page table, restores user registers,
        // and switches to user mode with sret.
        let fn_0: usize =
            TRAMPOLINE + unsafe { userret.as_ptr().offset_from(trampoline.as_ptr()) } as usize;
        let fn_0 = unsafe { mem::transmute::<_, unsafe extern "C" fn(usize, usize) -> !>(fn_0) };
        unsafe { fn_0(TRAPFRAME, user_table) }
    }
}

impl KernelRef<'_, '_> {
    /// `cur_el_sp0_handler` can be reached from the kernel mode, so it is a method of `Kernel`
    /// current el with SP0: this case is not allowed here
    unsafe fn kernel_trap_el1t(self, _etype: ExceptionTypes) {
        assert!(
            SPSR_EL1.matches_all(SPSR_EL1::M::EL1t),
            "kerneltrap: not from supervisor mode"
        );
        assert!(!intr_get(), "kerneltrap: interrupts enabled");

        self.print_state();
        panic!("kerneltrap")
    }

    /// `cur_el_sp1_handler` can be reached from the kernel mode, so it is a method of `Kernel`
    /// current el with SP1
    unsafe fn kernel_trap_el1h(self, etype: ExceptionTypes) {
        let elr_el1 = ELR_EL1.get();
        let spsr_el1 = SPSR_EL1.get();
        let fpsr = r_fpsr();

        assert!(
            SPSR_EL1.matches_all(SPSR_EL1::M::EL1h),
            "kerneltrap: not from supervisor mode"
        );
        assert!(!intr_get(), "kerneltrap: interrupts enabled");

        let irq = match etype {
            ExceptionTypes::SyncException | ExceptionTypes::FIQ | ExceptionTypes::SError => {
                self.print_state();
                panic!("kerneltrap")
            }
            ExceptionTypes::IRQ => unsafe { self.handle_irq() },
        };

        // barrier();
        if irq == 2 {
            // TODO(https://github.com/kaist-cp/rv6/issues/517): safety?
            if let Some(ctx) = unsafe { self.get_ctx() } {
                // SAFETY:
                // Reading state without lock is safe because `proc_yield` and `sched`
                // is called after we check if current process is `RUNNING`.
                if unsafe { (*ctx.proc().info.get_mut_raw()).state } == Procstate::RUNNING {
                    ctx.yield_cpu();
                }
            }
        }
        // barrier();

        // The yield may have caused some traps to occur,
        // so restore trap registers
        ELR_EL1.set(elr_el1);
        SPSR_EL1.set(spsr_el1);
        unsafe { w_fpsr(fpsr) };
    }

    fn print_state(self) {
        let elr_el1 = ELR_EL1.get();
        let spsr_el1 = SPSR_EL1.get();
        let far_el1 = FAR_EL1.get();
        let esr_el1 = ESR_EL1.get();

        self.as_ref()
            .write_fmt(format_args!("esr_el1: {:018p}\n", esr_el1 as *const u8));
        self.as_ref().write_fmt(format_args!(
            "spsr_el1={:018p} far_el1={:018p} elr_el1={:018p}\n",
            spsr_el1 as *const u8, far_el1 as *const u8, elr_el1 as *const u8
        ));
    }

    // TODO: refactor this function
    unsafe fn handle_irq(self) -> usize {
        // TODO
        let irq = INTERRUPT_CONTROLLER.fetch();

        match irq {
            Some(i) => {
                match i {
                    TIMER0_IRQ => {
                        if cpu_id() == 0 {
                            self.clock_intr();
                        }
                        Timer::set_next_timer();
                    }
                    MemLayout::UART0_IRQ => {
                        // SAFETY: it's unsafe only when ctrl+p is pressed.
                        unsafe { hal().console().intr(self) };
                    }
                    MemLayout::VIRTIO0_IRQ => {
                        hal().disk().pinned_lock().get_pin_mut().intr(self);
                    }
                    _ => {
                        // panic!("unexpected interrupt irq={}\n", irq);
                        return 0;
                    } // _ => panic!("unexpected interrupt irq={}\n", i)
                }
            }
            None => return 0,
        }
        if irq.is_some() {
            unsafe {
                INTERRUPT_CONTROLLER.finish(irq.unwrap());
            }
        }
        2
    }

    fn clock_intr(self) {
        let mut ticks = self.ticks().lock();
        *ticks = ticks.wrapping_add(1);
        ticks.wakeup(self);
    }
}
